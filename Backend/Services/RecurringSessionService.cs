using HDScheduler.API.Models;
using HDScheduler.API.Repositories;

namespace HDScheduler.API.Services;

public interface IRecurringSessionService
{
    Task<List<int>> GenerateRecurringSessions(HDSchedule baseSession, int weeksAhead = 1);
    List<DateTime> CalculateNextSessionDates(string hdCycle, DateTime startDate, int sessionsCount);
    Task<bool> ActivatePreScheduledSession(int scheduleId);
    Task<bool> MarkSessionAsMissed(int scheduleId, bool autoReschedule = false);
}

public class RecurringSessionService : IRecurringSessionService
{
    private readonly IHDScheduleRepository _scheduleRepository;
    private readonly ILogger<RecurringSessionService> _logger;

    public RecurringSessionService(
        IHDScheduleRepository scheduleRepository,
        ILogger<RecurringSessionService> logger)
    {
        _scheduleRepository = scheduleRepository;
        _logger = logger;
    }

    public async Task<List<int>> GenerateRecurringSessions(HDSchedule baseSession, int weeksAhead = 1)
    {
        var createdSessionIds = new List<int>();

        if (string.IsNullOrEmpty(baseSession.HDCycle))
        {
            return createdSessionIds; // No recurring schedule
        }

        // Calculate how many sessions to create (sessions per week * weeks ahead)
        var sessionsPerWeek = GetSessionsPerWeek(baseSession.HDCycle);
        var totalSessions = sessionsPerWeek * weeksAhead;

        // Calculate next session dates
        var nextDates = CalculateNextSessionDates(baseSession.HDCycle, baseSession.SessionDate, totalSessions);

        foreach (var nextDate in nextDates)
        {
            // Create pre-scheduled session with basic info only
            var recurringSession = new HDSchedule
            {
                PatientID = baseSession.PatientID,
                SessionDate = nextDate,
                
                // Copy basic HD information
                DryWeight = baseSession.DryWeight,
                HDStartDate = baseSession.HDStartDate,
                HDCycle = baseSession.HDCycle,
                DialyserType = baseSession.DialyserType,
                DialyserModel = baseSession.DialyserModel,
                PrescribedDuration = baseSession.PrescribedDuration,
                PrescribedBFR = baseSession.PrescribedBFR,
                DialysatePrescription = baseSession.DialysatePrescription,
                AccessType = baseSession.AccessType,
                AccessLocation = baseSession.AccessLocation,
                UFGoal = baseSession.UFGoal,
                AnticoagulationType = baseSession.AnticoagulationType,
                
                // Slot and bed (same slot, bed to be assigned)
                SlotID = baseSession.SlotID,
                BedNumber = null, // Let admin assign bed later
                
                // Mark as pre-scheduled
                SessionStatus = "Pre-Scheduled",
                IsAutoGenerated = true,
                ParentScheduleID = baseSession.ScheduleID,
                IsDischarged = false,
                CreatedByStaffName = baseSession.CreatedByStaffName,
                CreatedByStaffRole = baseSession.CreatedByStaffRole
            };

            try
            {
                var scheduleId = await _scheduleRepository.CreateAsync(recurringSession);
                createdSessionIds.Add(scheduleId);
                _logger.LogInformation("Created pre-scheduled session {ScheduleId} for patient {PatientId} on {Date}",
                    scheduleId, baseSession.PatientID, nextDate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to create pre-scheduled session for patient {PatientId} on {Date}",
                    baseSession.PatientID, nextDate);
            }
        }

        return createdSessionIds;
    }

    public List<DateTime> CalculateNextSessionDates(string hdCycle, DateTime startDate, int sessionsCount)
    {
        var dates = new List<DateTime>();
        var daysOfWeek = ParseHDCycleToDays(hdCycle);

        if (!daysOfWeek.Any())
            return dates;

        var currentDate = startDate.AddDays(1); // Start from next day
        var endDate = startDate.AddDays(7 * 2); // Look ahead 2 weeks max

        while (dates.Count < sessionsCount && currentDate <= endDate)
        {
            if (daysOfWeek.Contains(currentDate.DayOfWeek))
            {
                dates.Add(currentDate);
            }
            currentDate = currentDate.AddDays(1);
        }

        return dates;
    }

    public async Task<bool> ActivatePreScheduledSession(int scheduleId)
    {
        var session = await _scheduleRepository.GetByIdAsync(scheduleId);
        if (session == null || session.SessionStatus != "Pre-Scheduled")
            return false;

        session.SessionStatus = "Active";
        session.UpdatedAt = DateTime.Now;

        return await _scheduleRepository.UpdateAsync(session);
    }

    public async Task<bool> MarkSessionAsMissed(int scheduleId, bool autoReschedule = false)
    {
        var session = await _scheduleRepository.GetByIdAsync(scheduleId);
        if (session == null)
            return false;

        session.SessionStatus = "Missed";
        session.UpdatedAt = DateTime.Now;

        var result = await _scheduleRepository.UpdateAsync(session);

        if (result && autoReschedule)
        {
            // Auto-reschedule: Create new session for next available date
            var nextDate = CalculateNextSessionDates(session.HDCycle!, session.SessionDate, 1).FirstOrDefault();
            if (nextDate != default)
            {
                await GenerateRecurringSessions(session, 0); // Create one makeup session
            }
        }

        return result;
    }

    private List<DayOfWeek> ParseHDCycleToDays(string hdCycle)
    {
        var days = new List<DayOfWeek>();

        if (string.IsNullOrEmpty(hdCycle))
            return days;

        // Parse common HD cycle patterns
        hdCycle = hdCycle.ToUpper();

        if (hdCycle.Contains("MWF") || hdCycle.Contains("MONDAY") && hdCycle.Contains("WEDNESDAY") && hdCycle.Contains("FRIDAY"))
        {
            days.AddRange(new[] { DayOfWeek.Monday, DayOfWeek.Wednesday, DayOfWeek.Friday });
        }
        else if (hdCycle.Contains("TTS") || hdCycle.Contains("TUESDAY") && hdCycle.Contains("THURSDAY") && hdCycle.Contains("SATURDAY"))
        {
            days.AddRange(new[] { DayOfWeek.Tuesday, DayOfWeek.Thursday, DayOfWeek.Saturday });
        }
        else if (hdCycle.Contains("MTW"))
        {
            days.AddRange(new[] { DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday });
        }
        else if (hdCycle.Contains("DAILY") || hdCycle.Contains("6X"))
        {
            days.AddRange(new[] { DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday, 
                                  DayOfWeek.Thursday, DayOfWeek.Friday, DayOfWeek.Saturday });
        }

        return days;
    }

    private int GetSessionsPerWeek(string hdCycle)
    {
        if (string.IsNullOrEmpty(hdCycle))
            return 0;

        // Extract number from cycle string (e.g., "3x/week" => 3)
        if (hdCycle.Contains("3x") || hdCycle.Contains("3X"))
            return 3;
        if (hdCycle.Contains("6x") || hdCycle.Contains("6X") || hdCycle.Contains("DAILY"))
            return 6;
        if (hdCycle.Contains("2x") || hdCycle.Contains("2X"))
            return 2;

        // Default to 3 for common patterns like MWF or TTS
        return 3;
    }
}
